//a Imports
use std::collections::HashMap;

use clap::Command;

use thunderclap::CommandBuilder;

use ic_base::Ray;
use ic_camera::CameraProjection;
use ic_mapping::{CameraPtMapping, NamedPointSet, PointMappingSet};

use crate::cmd::{CmdArgs, CmdResult};

//a Help
//hi COMBINE_RAYS_FROM_MODEL_LONG_HELP
const COMBINE_RAYS_FROM_MODEL_LONG_HELP: &str = "\
This combines a list of rays from a JSON file and generates 
a model-space best location of ray intersection.

The rays in the file are from different model points and the direction
thereof should have been generated by casting rays through a camera
frame and applying in reverse the camera orientation.

Real-world rays will not intersect precisely; there will be a point
that has the minimum square distance from all the rays, though. This
is the point generated.

";

//hi GET_MODEL_POINTS_LONG_HELP
const GET_MODEL_POINTS_LONG_HELP: &str = "\
This combines camera location and PMS files, using them to determine
model positions for Named Points.

This takes a list of Camera/PMS files, and reads them in.  Then, for
each Named Point in the NPS file read in it calculates one ray from
each camera location in the direction given by the PMS for the ray,
creating N rays for N cameras.

The intersection of these N rays is then determined, yielding a
model-space point for the Named Point.

A new NamedPointSet is generated from the original NPS with these new
model-space points from the ray intersections.";

//hi PROJECT_LONG_HELP
const PROJECT_LONG_HELP: &str = "\
Project help";

//hi PROJECT_LONG_HELP
const LIST_LONG_HELP: &str = "\
List the information about one or more named points
";

//a CombineFrom
//fi combine_rays_from_model_cmd
fn combine_rays_from_model_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("combine_rays_from_model")
        .about("Combine rays from a model")
        .long_about(COMBINE_RAYS_FROM_MODEL_LONG_HELP);

    let mut build = CommandBuilder::new(command, Some(Box::new(combine_rays_from_model_fn)));
    CmdArgs::add_arg_ray_file(&mut build, (1,));
    build
}

//fi combine_rays_from_model_fn
fn combine_rays_from_model_fn(cmd_args: &mut CmdArgs) -> CmdResult {
    let named_rays = cmd_args.named_rays();

    let mut names = Vec::new();
    let mut ray_list = Vec::new();
    for (name, ray) in named_rays {
        names.push(name);
        ray_list.push(*ray);
    }
    if ray_list.len() <= 1 {
        return Err(format!(
            "Not enough rays ({}) to combine to generate a position for the camera",
            ray_list.len()
        )
        .into());
    }

    let position = Ray::closest_point(&ray_list, &|r| 1.0 / r.tan_error()).unwrap();
    eprintln!("The rays from the model converge at the camera focal point at {position}",);

    let mut tot_d_sq = 0.0;
    for (_name, ray) in names.iter().zip(ray_list.iter()) {
        let (_k, d_sq) = ray.distances(&position);
        cmd_args.if_verbose(|| {
            eprintln!("{}: k {} dsq {} d {}", _name, _k, d_sq, d_sq.sqrt());
        });
        tot_d_sq += d_sq;
    }

    eprintln!("Total dsq {tot_d_sq}");

    cmd_args.camera_mut().set_position(position);
    let camera = cmd_args.camera();
    println!("{}", serde_json::to_string_pretty(&camera).unwrap());
    Ok("".into())
}

//fi combine_rays_from_camera_cmd
fn combine_rays_from_camera_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("combine_rays_from_camera").about("Combine rays from a camera");

    let mut build = CommandBuilder::new(command, Some(Box::new(combine_rays_from_camera_fn)));
    CmdArgs::add_arg_ray_file(&mut build, (1,));

    build
}

//fi combine_rays_from_camera_fn
fn combine_rays_from_camera_fn(cmd_args: &mut CmdArgs) -> CmdResult {
    let nps = cmd_args.nps();
    let named_rays = cmd_args.named_rays();

    let mut named_point_rays = HashMap::new();
    for (name, ray) in named_rays {
        if nps.borrow().get_pt(&name).is_none() {
            eprintln!(
                "Warning: failed to find point name '{}' in named point set",
                &name
            );
        } else {
            if !named_point_rays.contains_key(name) {
                named_point_rays.insert(name.to_owned(), Vec::new());
            }
            named_point_rays.get_mut(name).unwrap().push(*ray);
        }
    }

    let mut k: Vec<String> = named_point_rays.keys().cloned().collect();
    k.sort();
    for name in &k {
        let ray_list = named_point_rays.get(name).unwrap();
        if ray_list.len() > 1 {
            let p = Ray::closest_point(ray_list, &|r| 1.0 / r.tan_error()).unwrap();
            eprintln!("Point '{name}' - even weight - {p}");
        }
    }

    Ok("".into())
}

//a Get model points
//fi get_model_points_cmd
fn get_model_points_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("get_model_points")
        .about("Get model points from camera and pms")
        .long_about(GET_MODEL_POINTS_LONG_HELP);

    let mut build = CommandBuilder::new(command, Some(Box::new(get_model_points_fn)));
    CmdArgs::add_arg_pms(&mut build); // used to be positional

    build
}

//fi get_model_points_fn
fn get_model_points_fn(cmd_args: &mut CmdArgs) -> CmdResult {
    // let pms = cmd_args.pms();
    let nps = cmd_args.nps();

    //
    let camera_pms: Vec<(ic_camera::CameraInstance, PointMappingSet)> = vec![]; //

    // was camera JSON, PMS json pairs
    // cmdline_args::mapping::get_camera_pms(matches, &base_args.cdb(), &base_args.nps())?;

    let mut result_nps = NamedPointSet::default();
    for (name, np) in nps.borrow().iter() {
        let mut ray_list = Vec::new();
        for (camera, pms) in camera_pms.iter() {
            if let Some(pm) = pms.mapping_of_np(np) {
                let ray = camera.get_pm_as_ray(pm, true);
                ray_list.push(ray);
            }
        }
        if ray_list.len() > 1 {
            if let Some(pt) = Ray::closest_point(&ray_list, &|_r| 1.0) {
                let e_sq = ray_list
                    .iter()
                    .fold(f64::MAX, |acc, r| acc.min(r.distances(&pt).1));
                result_nps.add_pt(name, *np.color(), Some(pt), e_sq.sqrt());
                cmd_args.if_verbose(|| {
                    for r in ray_list {
                        eprintln!("Ray to {name} {:?}", r.distances(&pt));
                    }
                });
            }
        }
    }
    println!("{}", serde_json::to_string_pretty(&result_nps).unwrap());
    Ok("".into())
}

//a List command
//fi list_cmd
fn list_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("list")
        .about("List information about named points")
        .long_about(LIST_LONG_HELP);

    CommandBuilder::new(command, Some(Box::new(list_fn)))
}

//fi list_fn
fn list_fn(cmd_args: &mut CmdArgs) -> CmdResult {
    let nps = cmd_args.get_nps()?;
    for np in nps {
        println!("{np}");
    }
    Ok("".into())
}

//a Named points command
//fi named_points_cmd
pub fn named_points_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("named_points")
        .about("Operate on the named points for a project")
        .long_about(PROJECT_LONG_HELP);

    let mut build = CommandBuilder::new(command, None);

    CmdArgs::add_arg_named_point(&mut build, (0,));

    build.add_subcommand(combine_rays_from_model_cmd());
    build.add_subcommand(combine_rays_from_camera_cmd());
    build.add_subcommand(get_model_points_cmd());
    build.add_subcommand(list_cmd());

    build
}
