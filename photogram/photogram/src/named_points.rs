//a Imports
use std::collections::HashMap;

use clap::Command;

use thunderclap::CommandBuilder;

use ic_base::{Ray, Rrc};
use ic_camera::CameraProjection;
use ic_image::Color;
use ic_mapping::{CameraPtMapping, NamedPoint, NamedPointSet, PointMappingSet};
use ic_project::Cip;

use crate::cmd::{CmdArgs, CmdResult};

//a Help
//hi COMBINE_RAYS_FROM_MODEL_LONG_HELP
const COMBINE_RAYS_FROM_MODEL_LONG_HELP: &str = "\
This combines a list of rays from a JSON file and generates 
a model-space best location of ray intersection.

The rays in the file are from different model points and the direction
thereof should have been generated by casting rays through a camera
frame and applying in reverse the camera orientation.

Real-world rays will not intersect precisely; there will be a point
that has the minimum square distance from all the rays, though. This
is the point generated.

";

//hi GET_MODEL_POINTS_LONG_HELP
const GET_MODEL_POINTS_LONG_HELP: &str = "\
This combines camera location and PMS files, using them to determine
model positions for Named Points.

This takes a list of Camera/PMS files, and reads them in.  Then, for
each Named Point in the NPS file read in it calculates one ray from
each camera location in the direction given by the PMS for the ray,
creating N rays for N cameras.

The intersection of these N rays is then determined, yielding a
model-space point for the Named Point.

A new NamedPointSet is generated from the original NPS with these new
model-space points from the ray intersections.";

//hi PROJECT_LONG_HELP
const PROJECT_LONG_HELP: &str = "\
Project help";

//hi LIST_LONG_HELP
const LIST_LONG_HELP: &str = "\
List the information about one or more named points
";

//hi ADD_LONG_HELP
const ADD_LONG_HELP: &str = "\
Add a named point to the set
";

//hi UPDATE_MODEL_LONG_HELP
const UPDATE_MODEL_LONG_HELP: &str = "\
Add and/or update model positions for all named points in the supplied JSON
";

//a CombineFrom
//fi combine_rays_from_model_cmd
fn combine_rays_from_model_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("combine_rays_from_model")
        .about("Combine rays from a model")
        .long_about(COMBINE_RAYS_FROM_MODEL_LONG_HELP);

    let mut build = CommandBuilder::new(command, Some(Box::new(combine_rays_from_model_fn)));
    CmdArgs::add_arg_ray_file(&mut build, (1,));
    build
}

//fi combine_rays_from_model_fn
fn combine_rays_from_model_fn(cmd_args: &mut CmdArgs) -> CmdResult {
    let named_rays = cmd_args.named_rays();

    let mut names = Vec::new();
    let mut ray_list = Vec::new();
    for (name, ray) in named_rays {
        names.push(name);
        ray_list.push(*ray);
    }
    if ray_list.len() <= 1 {
        return Err(format!(
            "Not enough rays ({}) to combine to generate a position for the camera",
            ray_list.len()
        )
        .into());
    }

    let position = Ray::closest_point(&ray_list, &|r| 1.0 / r.tan_error()).unwrap();
    eprintln!("The rays from the model converge at the camera focal point at {position}",);

    let mut tot_d_sq = 0.0;
    for (_name, ray) in names.iter().zip(ray_list.iter()) {
        let (_k, d_sq) = ray.distances(&position);
        cmd_args.if_verbose(|| {
            eprintln!("{}: k {} dsq {} d {}", _name, _k, d_sq, d_sq.sqrt());
        });
        tot_d_sq += d_sq;
    }

    eprintln!("Total dsq {tot_d_sq}");

    cmd_args.camera_mut().set_position(position);
    let camera = cmd_args.camera();
    println!("{}", serde_json::to_string_pretty(&camera).unwrap());
    Ok("".into())
}

//fi combine_rays_from_camera_cmd
fn combine_rays_from_camera_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("combine_rays_from_camera").about("Combine rays from a camera");

    let mut build = CommandBuilder::new(command, Some(Box::new(combine_rays_from_camera_fn)));
    CmdArgs::add_arg_ray_file(&mut build, (1,));

    build
}

//fi combine_rays_from_camera_fn
fn combine_rays_from_camera_fn(cmd_args: &mut CmdArgs) -> CmdResult {
    let nps = cmd_args.nps();
    let named_rays = cmd_args.named_rays();

    let mut named_point_rays = HashMap::new();
    for (name, ray) in named_rays {
        if nps.borrow().get_pt(name).is_none() {
            eprintln!(
                "Warning: failed to find point name '{}' in named point set",
                &name
            );
        } else {
            if !named_point_rays.contains_key(name) {
                named_point_rays.insert(name.to_owned(), Vec::new());
            }
            named_point_rays.get_mut(name).unwrap().push(*ray);
        }
    }

    let mut k: Vec<String> = named_point_rays.keys().cloned().collect();
    k.sort();
    for name in &k {
        let ray_list = named_point_rays.get(name).unwrap();
        if ray_list.len() > 1 {
            let p = Ray::closest_point(ray_list, &|r| 1.0 / r.tan_error()).unwrap();
            eprintln!("Point '{name}' - even weight - {p}");
        }
    }

    Ok("".into())
}

//a Get model points
//fi get_model_points_cmd
fn get_model_points_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("get_model_points")
        .about("Get model points from camera and pms")
        .long_about(GET_MODEL_POINTS_LONG_HELP);

    let mut build = CommandBuilder::new(command, Some(Box::new(get_model_points_fn)));

    CmdArgs::add_arg_named_point(&mut build, (None, false));

    CmdArgs::add_arg_positional_usize(
        &mut build,
        "cip",
        "Cip numbers to use for the point mappings",
        None,
        None,
    );

    build
}

//fi get_model_points_fn
fn get_model_points_fn(cmd_args: &mut CmdArgs) -> CmdResult {
    let nps = cmd_args.get_nps()?;

    let cips: Vec<_> = cmd_args
        .arg_usizes()
        .iter()
        .map(|cip| {
            /* bound it */
            let cip = cmd_args.project.cip(*cip).borrow();
            (cip.pms().clone(), cip.camera().clone())
        })
        .collect();

    let mut result_nps = NamedPointSet::default();
    for np in nps {
        let mut ray_list = Vec::new();
        for (pms, camera) in &cips {
            if let Some(pm) = pms.borrow().mapping_of_np(&np) {
                let ray = camera.borrow().get_pm_as_ray(pm, true);
                ray_list.push(ray);
            }
        }
        if ray_list.len() > 1 {
            if let Some(pt) = Ray::closest_point(&ray_list, &|_r| 1.0) {
                let e_sq = ray_list
                    .iter()
                    .fold(f64::MAX, |acc, r| acc.min(r.distances(&pt).1));
                result_nps.add_pt(np.name(), *np.color(), Some(pt), e_sq.sqrt());
                cmd_args.if_verbose(|| {
                    for r in ray_list {
                        eprintln!("Ray to {} {:?}", np.name(), r.distances(&pt));
                    }
                });
            }
        }
    }
    result_nps.to_json(false)
}

//a List, add command
//fi list_cmd
fn list_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("list")
        .about("List information about named points")
        .long_about(LIST_LONG_HELP);

    let mut build = CommandBuilder::new(command, Some(Box::new(list_fn)));

    CmdArgs::add_arg_named_point(&mut build, (None, true));

    build
}

//fi list_fn
fn list_fn(cmd_args: &mut CmdArgs) -> CmdResult {
    let nps = cmd_args.get_nps()?;
    for np in nps {
        println!("{np}");
    }
    Ok("".into())
}

//fi add_cmd
fn add_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("add")
        .about("Add a named point")
        .long_about(ADD_LONG_HELP);

    let mut build = CommandBuilder::new(command, Some(Box::new(add_fn)));

    CmdArgs::add_arg_positional_string(&mut build, "name", "Name of point to add", Some(1), None);
    CmdArgs::add_arg_positional_string(&mut build, "color", "Color of point", Some(1), None);
    CmdArgs::add_arg_positional_string(&mut build, "point3d", "Posiiton in 3D", Some(0), None);
    CmdArgs::add_arg_positional_f64(
        &mut build,
        "error",
        "Error radius in 3D",
        Some(0),
        Some("5.0"),
    );

    build
}

//fi add_fn
fn add_fn(cmd_args: &mut CmdArgs) -> CmdResult {
    let name = cmd_args.get_string_arg(0).unwrap();
    let color: Color = cmd_args.get_string_arg(1).unwrap().try_into()?;
    let mut model = None;
    if cmd_args.arg_strings.len() > 2 {
        model = Some((
            cmd_args.arg_as_point3d(2)?,
            cmd_args.get_f64_arg(0).unwrap_or(0.0),
        ));
    }
    if cmd_args.project().nps_ref().get_pt(&name).is_some() {
        return Err(format!("Named point {name} already exists in the set").into());
    }

    let np = NamedPoint::new(name, color, model);
    cmd_args.project().nps_mut().add_np(&np);
    Ok("".into())
}

//fi update_model_cmd
fn update_model_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("update_model")
        .about("Update_Model a named point")
        .long_about(UPDATE_MODEL_LONG_HELP);

    let mut build = CommandBuilder::new(command, Some(Box::new(update_model_fn)));

    CmdArgs::add_arg_positional_string(
        &mut build,
        "json",
        "Named point set JSON to update with",
        Some(1),
        None,
    );

    build
}

//fi update_model_fn
fn update_model_fn(cmd_args: &mut CmdArgs) -> CmdResult {
    let json = cmd_args.get_string_arg(0).unwrap();
    let new_nps = NamedPointSet::from_json(json)?;
    for (new_name, new_np) in new_nps.iter() {
        if let Some(np) = cmd_args.nps().borrow().get_pt(new_name) {
            if let Some(new_np_model) = new_np.opt_model() {
                // if let Some() = np.opt_model()...
                np.set_model(Some(new_np_model));
            }
        } else {
            cmd_args.nps().borrow_mut().add_np(new_np);
        }
    }
    Ok("".into())
}

//a Named points command
//fi named_points_cmd
pub fn named_points_cmd() -> CommandBuilder<CmdArgs> {
    let command = Command::new("named_points")
        .about("Operate on the named points for a project")
        .long_about(PROJECT_LONG_HELP);

    let mut build = CommandBuilder::new(command, None);

    build.add_subcommand(combine_rays_from_model_cmd());
    build.add_subcommand(combine_rays_from_camera_cmd());
    build.add_subcommand(get_model_points_cmd());
    build.add_subcommand(list_cmd());
    build.add_subcommand(add_cmd());
    build.add_subcommand(update_model_cmd());

    build
}
